$ gcc -g  main.c  //编译生成带有调试信息的执行文件a.tou 

$ gdb a.out //调试程序 

$ gdb -tui ./a.out  //开启图形界面 （紧接在gdb下要输入layout asm, layout regs）（下表为常用快捷键）

​	可以使用 finish 退出某个函数的单步调试

| 快捷键                | 功能                   |
| --------------------- | ---------------------- |
| `Ctrl + L`            | 刷新屏幕               |
| `Ctrl + X` 然后 `1~3` | 不同视图模式切换       |
| `Ctrl + X` 然后 `A`   | 显示或隐藏源码窗口     |
| `n`, `s`, `c`         | 下一行、单步、继续执行 |
| `q`                   | 退出                   |



$ l     //list: 查看源码(默认10行)        //list 8  查看8行附近的代码        //list main 查看函数名附近的码 

$ b 5   //break: 在第5行设置断点 

$ r     //run: 运行到断点处（如无则运行直到结束） 

$ s     //step: 单步执行（如果是函数则进入） 

$ n     //next: 单步跳过（如果是函数则跳过） 

$ p a   //print: 查看变量内容        

​			// p &a  查看变量a的地址       

​			 // p &b+1   b变量的地址根据数据类型递增(int型 会加4，char型则加1)      

​			 // p *(&b+1)        

​			// p a[1]        

​			// p *p1 查看p1指针里的内容        

 			// p  add(4,7)  调用函数add 并打印返回值 

$ p/t b // t  二进制显示 变量的值  

​			 // x  按十六进制格式显示变量。 

​			// d  按十进制格式显示变量。

 			// u  按十六进制格式显示无符号整型。 

​			// o  按八进制格式显示变量。 

​			// a  按十六进制格式显示变量。 

​			// c  按字符格式显示变量。 

​			// f  按浮点数格式显示变量。       

$ x &a  //显示某地址的内存值        

 			//例如 float a = 0.45; 的内存值为        

​			// 0x7fffffffdf8c:	00111110111001100110011001100110         

上下键  //可查看历史命令 

$ bt     //查看堆栈信息 （如嵌套调用多个函数时） 

$ c      //continue： 继续执行程序（直到下一个断点或者结束） 

$ q      //quit: 退出gdb调试 

$ dmesg  //查看内核信息     



在调试器（如 `gdb`）中，使用指针运算来观察数组元素和指针地址会产生不同的结果。以下是对这两个调试结果差异的解释：

### 数组定义

首先，我们有一个字符数组定义：

```c
char a[5] = {'a', 'b', 'c', 'd', 'e'};
```

### 指针运算解释

#### 1. `p &a[0] + 1`

```c
(gdb) p &a[0] + 1
$10 = 0x7fffffffdfe4 "bcde"
```

- `&a[0]` 获取数组 `a` 第一个元素的地址。
- `&a[0] + 1` 将该地址加1，得到第二个元素的地址，即 `&a[1]`。
- 当我们打印这个地址的内容时，`gdb` 解释为从该地址开始的字符串，因此显示为 `"bcde"`，这是从 `a[1]` 开始到数组结尾的所有字符。

#### 2. `p &a + 1`

```c
(gdb) p &a+1
$11 = (char (*)[5]) 0x7fffffffdfe8
```

- `&a` 获取整个数组 `a` 的地址，类型是 `char (*)[5]`，即指向一个包含5个字符的数组的指针。
- `&a + 1` 将该指针加1，意味着跳过整个数组 `a` 的大小。
  - `a` 是一个长度为5的字符数组，因此 `&a + 1` 实际上是跳过这5个字符后的地址。
  - 如果 `a` 起始地址是 `0x7fffffffdfe3`，那么 `&a + 1` 就是 `0x7fffffffdfe8`（假设每个字符占用1个字节，5个字符加起来就是5个字节）。

### 总结

1. `p &a[0] + 1` 结果为 `0x7fffffffdfe4 "bcde"`：
   - 这是数组中第二个元素（`'b'`）的地址，`gdb` 按字符串解释该地址，所以显示为 `"bcde"`。

2. `p &a + 1` 结果为 `0x7fffffffdfe8`：
   - 这是跳过整个数组 `a` 后的地址，类型是 `char (*)[5]`。地址值是数组 `a` 末尾之后的位置。

这些结果表明指针运算在不同上下文中的行为差异：一个是针对数组元素指针的运算，另一个是针对整个数组指针的运算。

